# 1. Wireshark

1.1 Мой компьютер использует IP-адрес 192.168.1.103 и порт 54712.
<img width="1440" alt="1 1" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/e404d772-a304-4300-bc97-5fd9f82d80d5">

1.2 У сервера gaia.cs.umass.edu IP-адрес 128.119.245.12, порт для отправки 54712 и порт для приёма 80.
<img width="1440" alt="1 2" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/da7553df-9f19-47be-a8cc-bdc4c5631820">

1.3 У SYN TCP-сегмента, который используется для установления TCP-соединения, относительный порядковый номер 0 и абсолютный порядковый номер 4207950075. Определить, что это SYN сегмент, можно по флагу SYN этого сегмента.
<img width="1440" alt="1 3" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/4a730581-5d73-4305-a2c0-68d154a42fdd">

1.4. У SYNACK-сегмента, отправленного в ответ на SYN-сегмент, относительный порядковый номер 0 и абсолютный порядковый номер 4255824796. В его поле подтверждения хранится относительное значение 1 и абсолютное значение 4207950076. Сервер определил эти значения как порядковый номер SYN-сегмента плюс 1. Понять, что это SYNACK-сегмент, можно по флагам SYN и ACK этого сегмента.
<img width="1440" alt="1 4" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/76513da3-5fe2-4f1f-9627-267f6115f2f1">

1.5. У TCP-сегмента, содержащего команду POST, относительный порядковый номер 1 и абсолютный порядковый номер 3539777223.
<img width="1440" alt="1 5" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/26f65f2f-ee52-4e8b-b195-3ed4183d9eb9">

1.6. Относительные порядковые номера первых шести TCP-сегментов: 1, 631, 2079, 3527, 4975, 6423. Абсолютные порядковые номера: 3539777223, 3539777853, 3539779301, 3539780749, 3539782197, 3539783645. Времена отправления: 17:34:39.379696, 17:34:39.379821, 17:34:39.379824, 17:34:39.379825, 17:34:39.379827, 17:34:39.379828. Времена получения подтверждений: 17:34:39.583054, 17:34:39.66761, 17:34:39.667612, 17:34:39.667613, 17:34:39.667613, 17:34:39.667613. RTT (из графика): ~288мс для каждого сегмента.
<img width="1440" alt="1 6 71" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/5ecb82fe-f046-40e9-a807-763ee08df899">
<img width="1440" alt="1 6 72" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/1de490fa-415f-4db6-bacf-7b64c0267cef">
<img width="1440" alt="1 6 73" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/09f62967-ba87-41e4-bd64-2ea7768ffe97">
<img width="1440" alt="1 6 74" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/2eb53aee-821d-45ef-a1cb-931a534aef8f">
<img width="1440" alt="1 6 75" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/136fdabb-029d-4091-a7ff-db7ff7ed9054">
<img width="1440" alt="1 6 76" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/b46f45d7-f80d-48ec-af17-fc3f26a9da9d">
<img width="1440" alt="1 6 graph" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/8385de92-39a2-4e12-ba68-713d1c95bb98">

1.7. Разница во времени между первым SYN-сегментом и последним ACK-сегментом равна 1.912985с. Размер файла alice.txt равен 152138 байт. Пропускная способность этого соединения равна $\frac{152138}{1.912985}$ байт/с $\approx 79529.11$ байт/с.
<img width="1440" alt="1 7 ACK" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/ba7b0f96-cea8-49bb-8e4a-d4e348b38a2b">
<img width="1440" alt="1 7 SYN" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/26265317-c225-40c2-a775-0d384df37d80">

2.
<img width="1440" alt="2" src="https://github.com/sergeyrid/CompNetHW/assets/41862239/9b94e3f7-27ce-48ed-bb87-c16e28b838f5">

# 3. Задачки

## 1

1. Для GBN:

Пусть окно передачи равно $k$. Тогда проблема может возникнуть таким образом: отправитель отправит $k$ пакетов, получатель их примет, но до отправителя не дойдут подтверждения, и он переотправит пакет $0$, а получатель воспримет его как следующий пакет по порядку. Значит наибольшее возможное окно $\leq k-1$. Пусть окно $\leq k-1$. Предположим, что отправитель отправил пакет $i$ повторно, а получатель воспринял его как новый пакет. Раз получатель воспринял пакет $i$ как новый, то это значит, что он обработал его предыдущий раз и также обработал все следующие после него номера пакетов до $k$ и заново номера пакетов с $0$ до $i-1$ включительно. Но для этого со стороны отправителя в окно должны были одновременно попасть все номера большие $i$, все номера меньшие $i$, и ещё $i$, так как он посылается повторно. Но тогда размер окна $\geq k$, противоречие. Таким образом максимальный размер окна равен $k-1$.

2. Для SR:

Пусть окно передачи равно $\lfloor \frac{k}{2} \rfloor + 1$. Тогда проблема может возникнуть таким образом: отправитель отправит $\lfloor \frac{k}{2} \rfloor + 1$ пакетов, получатель их примет, но до отправителя не дойдут подтверждения, и он переотправит пакет $0$, но получатель уже сдвинет своё окно на $\lfloor \frac{k}{2} \rfloor + 1$ и добавит этот пакет в буфер как новый. Значит наибольшее возможное окно $\leq \lfloor \frac{k}{2} \rfloor$. Пусть окно $\leq \lfloor \frac{k}{2} \rfloor$. Предположим, что отправитель отправил пакет $i$ повторно, а получатель воспринял его как новый пакет. Раз получатель воспринял пакет $i$ как новый, то это значит, что он обработал его предыдущий раз, принял вместе с ним $\leq \lfloor \frac{k}{2} \rfloor$ пакетов и сдвинули конец окна на $\leq 2 \lfloor \frac{k}{2} \rfloor - 1 \leq k-1$. Но тогда новый пакет с номером $i$ не входит в окно, противоречие. Таким образом максимальный размер окна равен $\lfloor \frac{k}{2} \rfloor$.

## 2

Требуется, чтобы выполнялось $n \cdot \frac{1500}{30}$ байт/мс $> 0.98 \cdot 10^9$ бит/с $\Rightarrow n \cdot \frac{12000}{0.03}$ бит/с $> 0.98 \cdot 10^9$ бит/с $\Rightarrow n > \frac{0.98 \cdot 10^9 \cdot 0.03}{12000} = 2450 \Rightarrow n \geq 2451$.
